[{"content":"A simple Bash Implementation 相信很多人在学习 Linux 时，接触到的第一个程序就是 Bash。\n什么？你不知道什么是 Bash？\n没关系，你一定见过下面这样的命令行界面：\n其实，这个以 $ 开头、等待你输入命令的界面，就是 Bash。\n在 Bash 中，我们可以通过多种方式运行程序，例如：\n直接运行程序：如 ls -l\n使用管道 (pipe)：将两个程序的输入输出连接在一起，比如 cat hello.txt | grep \u0026quot;hello\u0026quot;\n使用分号 (;)：运行多个命令，例如 mkdir hello; echo \u0026quot;hello\u0026quot; \u0026gt; hello\n使用 \u0026amp;：将任务放到后台运行\n这些方式背后的逻辑都由 Bash 来处理和执行。那么，它是如何实现的呢？接下来，我们以 xv6 中的 sh.c 源码为例，简单探索一个 Shell 的核心功能。\n回顾Shell的行为 在深入代码之前，我们先来回顾一下 Shell 的常见行为：\n​\t1. 直接输入命令：比如 ls，结果会立即显示到屏幕上，随后等待输入下一条命令。\n​\t2. 运行耗时命令：例如删除一个包含大量文件的文件夹时，Bash 会暂停，直到操作完成。\n​\t3. 后台运行命令：使用 \u0026amp;，如 sleep 10 \u0026amp;，Bash 会立即返回提示符，不会阻塞。\n基于以上行为，一个简单的 Bash 实现可能类似如下代码\nint main(){ char cmd[512]; while (true) { get_cmd(cmd, sizeof(cmd)); // 获取用户输入的命令 if (fork() == 0) { // 子进程执行命令 run_cmd(cmd); } wait(0); // 父进程等待子进程结束 } } 在这个实现中：\n主循环不断读取用户输入。\n每次通过 fork 创建一个子进程来运行命令。\n主进程会等待子进程完成。这也是为什么运行耗时命令时，Bash 界面会“卡住”的原因。\n通过这样的结构，Bash 能够实现基本的命令执行和进程管理。接下来，我们将结合源码深入探讨这些功能的具体实现。熟悉面向对象编程的朋友可能会想到：我们可以将基本命令设计为基类，然后为不同的情况定义子类来处理特定逻辑。虽然 C 语言没有直接支持多态或继承，但我们可以通过结构体和函数指针实现类似的设计模式。\n利用结构体模拟面向对象 struct cmd{ int type; }; struct execcmd{ // 直接执行命令 int type; char *argv[MAXARGS]; char *eargv[MAXARGS]; }; struct pipecmd{ // 执行管道命令 int type; struct cmd* left; // 管道左边[生产者] struct cmd* right; // 管道右边[消费者] }; struct listcmd{ // 列表命令 int type; struct cmd* left; struct cmd* right; }; struct backcmd{ // 后台命令 int type; struct cmd* cmd; } 结构体设计的关键点 1.通用性：所有结构体都包含 type 字段，用于标识命令的类型，便于在运行时区分。 2.扩展性：通过为每种命令类型定义特定的结构体字段，增加了处理复杂场景的灵活性。 3.组合设计：结构体可以嵌套使用，例如在管道命令和列表命令中，通过指向 struct cmd 的指针，递归表示多层命令结构。\n通过这种设计，C 语言得以在没有面向对象特性的情况下，优雅地处理不同类型的命令。这种方法不仅保持了代码的组织性，还为扩展功能提供了清晰的框架。接下来，我们将结合具体的命令解析与执行流程，深入分析 xv6 中的实现细节。\n在具体实现过程中，一个关键步骤是对命令运行模式的识别。比如，通过分号 ; 判断是列表命令，通过\u0026amp; 判断是后台命令。我们假设这部分已经由一个名为 parsecmd 的函数完成：\nstruct cmd* parsecmd(char* buf) { ... ... return cmd; //返回初始化后的结构体指针 } parsecmd 返回的 cmd 指针包含了命令的类型信息 (type)，用于区分具体的命令类型。接下来，通过 runcmd 函数，针对不同类型的命令实现对应的处理逻辑：\nswitch(cmd-\u0026gt;type) { case EXEC: ecmd = (struct execcmd*)cmd; exec(ecmd-\u0026gt;argv[0]), ecmd-\u0026gt;argv) break; case LIST: lcmd = (struct listcmd*)cmd; if(fork() == 0) runcmd(lcmd-\u0026gt;left); wait(0); runcmd(lcmd-\u0026gt;right); case PIPE: pcmd = (struct pipecmd*)cmd; pipe(p); if(fork() == 0) { close(1); dup(p[1]); close(p[0]); close(p[1]); runcmd(pcmd-\u0026gt;left); } if(fork() == 0) { close(0); dup(p[0]); close(p[0]); close(p[1]); runcmd(pcmd-\u0026gt;left); } wait(0); wait(0); break; case BACK: bcmd = (struct backcmd*) cmd; if(fork() == 0) { runcmd(bcmd-\u0026gt;cmd); } break; } 接下来，我们分别解释这些命令类型的逻辑：\n基本命令(EXEC) EXEC 是最基本的命令类型，通常调用系统调用 exec 来运行程序。它需要提供程序的路径以及参数列表。在更复杂的命令中，EXEC 是最基本的单元。\n列表命令(LIST) 列表命令通过分号; 将命令串行执行。实现逻辑如下： 1.递归调用 runcmd 执行左侧命令（listcmd-\u0026gt;left）。 2.使用 wait 等待左侧命令完成。 3.执行右侧命令（listcmd-\u0026gt;right）。 左右命令可以是基本命令，也可以是更复杂的类型。\n后台命令(BACK) 后台命令使用 \u0026amp; 指定，表示命令在后台运行。实现逻辑如下： 1.调用 fork 创建一个子进程。 2.在子进程中递归调用 runcmd 执行命令。 3.父进程直接返回到 main 循环，继续读取下一条命令。\n这种方式确保后台命令不会阻塞 Bash 的命令行输入。\nPIPE命令逻辑 管道命令通过管道符 (|) 连接两个命令，用来将前一个命令的输出作为下一个命令的输入。实现逻辑如下： 1.调用 pipe 创建一个管道（pipe[0] 为输入，pipe[1] 为输出）。 2.使用 fork 创建两个子进程： • 子进程1：重定向标准输出到管道的写端，关闭不需要的管道端口，并递归调用 runcmd 执行左侧命令。 •子进程2：重定向标准输入到管道的读端，关闭不需要的管道端口，并递归调用 runcmd 执行右侧命令。 3.主进程关闭管道端口，并等待两个子进程完成。\n管道命令是 Bash 实现中较为复杂的部分，通过多次 fork 和 dup 操作实现了进程间的输入输出重定向。\n通过以上逻辑，runcmd 实现了对多种命令类型的灵活处理。结合 parsecmd 和 fork 等系统调用，这样的设计不仅结构清晰，还便于扩展其他命令类型。\n","permalink":"https://zhipzhang.github.io/zh/intro_bash/","summary":"\u003ch1 id=\"a-simple-bash-implementation\"\u003eA simple Bash Implementation\u003c/h1\u003e\n\u003cp\u003e相信很多人在学习 Linux 时，接触到的第一个程序就是 Bash。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e什么？你不知道什么是 Bash？\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e没关系，你一定见过下面这样的命令行界面：\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/image/bash.png\" alt=\"bash_image\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e其实，这个以 \u003ccode\u003e$\u003c/code\u003e 开头、等待你输入命令的界面，就是 Bash。\u003c/p\u003e\n\u003cp\u003e在 Bash 中，我们可以通过多种方式运行程序，例如：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e直接运行程序\u003c/strong\u003e：如 \u003ccode\u003els -l\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e使用管道 (\u003cstrong\u003epipe\u003c/strong\u003e)\u003c/strong\u003e：将两个程序的输入输出连接在一起，比如\u003ccode\u003e cat hello.txt | grep \u0026quot;hello\u0026quot;\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e使用分号 (\u003c/strong\u003e;\u003cstrong\u003e)\u003c/strong\u003e：运行多个命令，例如 \u003ccode\u003emkdir hello; echo \u0026quot;hello\u0026quot; \u0026gt; hello\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e使用\u003c/strong\u003e \u0026amp;：将任务放到后台运行\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这些方式背后的逻辑都由 Bash 来处理和执行。那么，它是如何实现的呢？接下来，我们以 xv6 中的 \u003ccode\u003esh.c\u003c/code\u003e 源码为例，简单探索一个 Shell 的核心功能。\u003c/p\u003e\n\u003ch2 id=\"回顾shell的行为\"\u003e回顾Shell的行为\u003c/h2\u003e\n\u003cp\u003e在深入代码之前，我们先来回顾一下 Shell 的常见行为：\u003c/p\u003e\n\u003cp\u003e​\t1. \u003cstrong\u003e直接输入命令\u003c/strong\u003e：比如 ls，结果会立即显示到屏幕上，随后等待输入下一条命令。\u003c/p\u003e\n\u003cp\u003e​\t2. \u003cstrong\u003e运行耗时命令\u003c/strong\u003e：例如删除一个包含大量文件的文件夹时，Bash 会暂停，直到操作完成。\u003c/p\u003e\n\u003cp\u003e​\t3. \u003cstrong\u003e后台运行命令\u003c/strong\u003e：使用 \u0026amp;，如 sleep 10 \u0026amp;，Bash 会立即返回提示符，不会阻塞。\u003c/p\u003e\n\u003cp\u003e基于以上行为，一个简单的 Bash 实现可能类似如下代码\u003c/p\u003e","title":"探究Bash"},{"content":"其实回想起来，从很早之前，我常常开始苛求着自己。或是在每天晚上感慨着今天又没有完成什么，又或是抱怨着过去的基础真的太差了。默默想来，我似乎从没有正视过过去的自己。大部分时间，我在自卑中度过，偶尔在完成一个小的里程碑的时候，又被自负所包围。\n如果正视现在的我，我到底是什么样的呢？过去两三年我似乎总有各种各样想做的，想学的事情：数学，线性代数，概率论，基础的物理学，辐射，计算机系统，计算机网络，编程\u0026hellip;.这么多的事情压的我喘不过气来。每天从早到晚想的都是如何能够多学一点，如何能够掌握的更多一些。大量的时间投入其中，但过去的我好像总在原地打转着，同一个知识点翻来覆去的看\u0026hellip;有时候才发现一本看了好几遍的书，甚至还是在看着前面的几章部分。稍微复杂、困难的部分还是每次都读不下去。思来想去，或许我错了。\n或许不是我不够努力、或许不是我不够聪明。而是我确实想要的太多了，很多时候我明显感觉到我太疲倦了，只是不断麻木的往前走着。生怕一停下来，与别人的距离就会越来越远。可是，扪心自问的话，我到底想要的是什么？很多时候不太理解我到底是被什么所驱使着。成功？功利心？已经这么活着太久了，所以好像越来越分不清哪些事情是我真正想做，哪些事情是因为功利心我逼着自己做了。\n如果有一天，我不再追求什么，我不再蒙蔽自己。那个时候，我会想做什么呢？不是为了成功，不是为了赚大钱，只是为了自己开心。\n","permalink":"https://zhipzhang.github.io/zh/thanks_past_me/","summary":"\u003cp\u003e其实回想起来，从很早之前，我常常开始苛求着自己。或是在每天晚上感慨着今天又没有完成什么，又或是抱怨着过去的基础真的太差了。默默想来，我似乎从没有正视过过去的自己。大部分时间，我在自卑中度过，偶尔在完成一个小的里程碑的时候，又被自负所包围。\u003c/p\u003e\n\u003cp\u003e如果正视现在的我，我到底是什么样的呢？过去两三年我似乎总有各种各样想做的，想学的事情：数学，线性代数，概率论，基础的物理学，辐射，计算机系统，计算机网络，编程\u0026hellip;.这么多的事情压的我喘不过气来。每天从早到晚想的都是如何能够多学一点，如何能够掌握的更多一些。大量的时间投入其中，但过去的我好像总在原地打转着，同一个知识点翻来覆去的看\u0026hellip;有时候才发现一本看了好几遍的书，甚至还是在看着前面的几章部分。稍微复杂、困难的部分还是每次都读不下去。思来想去，或许我错了。\u003c/p\u003e\n\u003cp\u003e或许不是我不够努力、或许不是我不够聪明。而是我确实想要的太多了，很多时候我明显感觉到我太疲倦了，只是不断麻木的往前走着。生怕一停下来，与别人的距离就会越来越远。可是，扪心自问的话，我到底想要的是什么？很多时候不太理解我到底是被什么所驱使着。成功？功利心？已经这么活着太久了，所以好像越来越分不清哪些事情是我真正想做，哪些事情是因为功利心我逼着自己做了。\u003c/p\u003e\n\u003cp\u003e如果有一天，我不再追求什么，我不再蒙蔽自己。那个时候，我会想做什么呢？不是为了成功，不是为了赚大钱，只是为了自己开心。\u003c/p\u003e","title":"感谢过去的我"},{"content":"ctapipe是CTA中对sim_telarray生成的文件进行分析的软件包，其中包括对波形积分、图像清理、重建等过程。之前开发的LAST实际很大一部分基于ctapipe进行开发，在未来我们也会以ctapipe为样本开发下一版本的LAST程序。因此在这里我们以ctapipe为基础，对重建的文件进行相应的分析。\n模拟数据的产生 首先我们使用corsika_run产生相应的corsika的数据，并使用sim_telarray进行相应的模拟。运行的脚本如下：\ncorsika_run --run-number 1 --corsika-path ~/Software/corsika-77410/run/corsika77410Linux_QGSII_urqmd --atmosphere 1 --altitude 4400 --template ./corsika.input # iact.zst will show in run000001 sim_telarray -i run000001/iact.zst -o simtel.zst 值得注意的是，为了全面的使用ctapipe，我们使用了完整的模拟参数，即对电子学波形也进行了相应的模拟，目前是基本上完全基于HESS的电子学参数。\n原始数据的分析 在下面我们展示了使用ctapipe读取simtel.zst文件，并进行相应的波形积分、参数化等过程。 Click here to view this notebook in full screen 数据的重建过程 除了可以对原始数据进行分析，我们还可以很方便的对数据进行相应的重建。下面我们展示对simtel.zst文件进行重建的过程。\nClick here to view this notebook in full screen ","permalink":"https://zhipzhang.github.io/zh/ctapipe_example/","summary":"\u003cp\u003e\u003ccode\u003ectapipe\u003c/code\u003e是CTA中对\u003ccode\u003esim_telarray\u003c/code\u003e生成的文件进行分析的软件包，其中包括对波形积分、图像清理、重建等过程。之前开发的\u003ccode\u003eLAST\u003c/code\u003e实际很大一部分基于\u003ccode\u003ectapipe\u003c/code\u003e进行开发，在未来我们也会以\u003ccode\u003ectapipe\u003c/code\u003e为样本开发下一版本的\u003ccode\u003eLAST\u003c/code\u003e程序。因此在这里我们以\u003ccode\u003ectapipe\u003c/code\u003e为基础，对重建的文件进行相应的分析。\u003c/p\u003e\n\u003ch2 id=\"模拟数据的产生\"\u003e模拟数据的产生\u003c/h2\u003e\n\u003cp\u003e首先我们使用\u003ccode\u003ecorsika_run\u003c/code\u003e产生相应的corsika的数据，并使用\u003ccode\u003esim_telarray\u003c/code\u003e进行相应的模拟。运行的脚本如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecorsika_run --run-number \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e --corsika-path ~/Software/corsika-77410/run/corsika77410Linux_QGSII_urqmd --atmosphere \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e --altitude \u003cspan style=\"color:#ae81ff\"\u003e4400\u003c/span\u003e --template ./corsika.input\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# iact.zst will show in run000001\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esim_telarray -i run000001/iact.zst -o simtel.zst\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e值得注意的是，为了全面的使用\u003ccode\u003ectapipe\u003c/code\u003e，我们使用了完整的模拟参数，即对电子学波形也进行了相应的模拟，目前是基本上完全基于\u003ccode\u003eHESS\u003c/code\u003e的电子学参数。\u003c/p\u003e\n\u003ch2 id=\"原始数据的分析\"\u003e原始数据的分析\u003c/h2\u003e\n\u003cp\u003e在下面我们展示了使用\u003ccode\u003ectapipe\u003c/code\u003e读取\u003ccode\u003esimtel.zst\u003c/code\u003e文件，并进行相应的波形积分、参数化等过程。\n\u003cp\u003e\n  \u003ca href=\"https://zhipzhang.github.io//jupyter/ctapipe-example.html\"\n    \u003eClick here to view this notebook in full screen\u003c/a\n  \u003e\n\u003c/p\u003e\n\u003ciframe\n  src=\"https://zhipzhang.github.io//jupyter/ctapipe-example.html\"\n  style=\"height:5000px;width:100%;border:none;overflow:hidden;\"\n  scrolling=\"no\"\n\u003e\u003c/iframe\u003e\n\u003c/p\u003e\n\u003ch2 id=\"数据的重建过程\"\u003e数据的重建过程\u003c/h2\u003e\n\u003cp\u003e除了可以对原始数据进行分析，我们还可以很方便的对数据进行相应的重建。下面我们展示对\u003ccode\u003esimtel.zst\u003c/code\u003e文件进行重建的过程。\u003c/p\u003e\n\u003cp\u003e\n  \u003ca href=\"https://zhipzhang.github.io//jupyter/ctapipe-reco.html\"\n    \u003eClick here to view this notebook in full screen\u003c/a\n  \u003e\n\u003c/p\u003e\n\u003ciframe\n  src=\"https://zhipzhang.github.io//jupyter/ctapipe-reco.html\"\n  style=\"height:1800px;width:100%;border:none;overflow:hidden;\"\n  scrolling=\"no\"\n\u003e\u003c/iframe\u003e\n\n\u003c!-- raw HTML omitted --\u003e\n\u003c!-- raw HTML omitted --\u003e","title":"Ctapipe data analysis for LACT"},{"content":"在sim_telarray中存在大量可以进行配置的文件。在这里我们对LACT_PROD0的配置进行解读，值得注意的是，考虑到现阶段LACT望远镜的配置还没有完全确定，在配置文件中我们很大程度参考了HESS的配置。\n配置概括 所有配置的入口文件为cfg/lact/lact.cfg,在这里我们使用include语句将其他配置文件引入。\n#include \u0026lt;LACT-camera.cfg\u0026gt; ... 为了方便配置我们将配置文件分为了以下几个模块：\nLACT-site.cfg: 站点的配置信息，包括海拔、大气模型等 LACT-common.cfg: 包括模拟中的一些基本信息 LACT-optics.cfg: 包括光学参数的配置信息 LACT-camera.cfg: 包括相机参数的配置信息 LACT-sipm.cfg: 包括SipM参数配置信息 ","permalink":"https://zhipzhang.github.io/zh/simtelarrayconfiguration/","summary":"\u003cp\u003e在\u003ccode\u003esim_telarray\u003c/code\u003e中存在大量可以进行配置的文件。在这里我们对\u003ccode\u003eLACT_PROD0\u003c/code\u003e的配置进行解读，值得注意的是，考虑到现阶段\u003ccode\u003eLACT\u003c/code\u003e望远镜的配置还没有完全确定，在配置文件中我们很大程度参考了\u003ccode\u003eHESS\u003c/code\u003e的配置。\u003c/p\u003e\n\u003ch2 id=\"配置概括\"\u003e配置概括\u003c/h2\u003e\n\u003cp\u003e所有配置的入口文件为\u003ccode\u003ecfg/lact/lact.cfg\u003c/code\u003e,在这里我们使用\u003ccode\u003einclude\u003c/code\u003e语句将其他配置文件引入。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include \u0026lt;LACT-camera.cfg\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e...\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e为了方便配置我们将配置文件分为了以下几个模块：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eLACT-site.cfg\u003c/code\u003e: 站点的配置信息，包括海拔、大气模型等\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eLACT-common.cfg\u003c/code\u003e: 包括模拟中的一些基本信息\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eLACT-optics.cfg\u003c/code\u003e: 包括光学参数的配置信息\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eLACT-camera.cfg\u003c/code\u003e: 包括相机参数的配置信息\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eLACT-sipm.cfg\u003c/code\u003e: 包括SipM参数配置信息\u003c/li\u003e\n\u003c/ul\u003e","title":"Sim_telarray LACT_PROD0 配置解读"},{"content":"考虑到在LACT模拟中需要大量依赖于hessioxxx以及sim_telarray工具包，而这两个工具包编译的过程比较繁琐，所以这里打算将这两个工具包进行改装，使其能够适应LACT的模拟需求。\nhessioxxx改装思路 在hessioxxx中，其存在大量为CTA以及HESS等项目定制的参数配置，因此在LACT进行使用的过程中及其不方便。考虑到最小化我们的修改情况，我们使用LACT_PROD参数来进行一键的配置。配置后我们可以使用下面的代码直接进行安装：\nmake EXTRA_OPTIONS=\u0026#39;-DLACT_PROD0` 以下是LACT_PROD0参数配置的说明表格：\n参数 值 说明 H_MAX_TEL 32 最大望远镜数量 H_MAX_PIX 3000 每个望远镜的最大像素数 H_MAX_GAINS 2 每个像素的最大增益通道数 H_MAX_PIXSECTORS 19 每个像素最多可以在多少个扇区之中 H_MAX_SECTORS H_MAX_PIX * 2 最大扇区数，为最大像素数的两倍 H_MAX_SLICES 128 最大采样的时间(ns) 修改的第二个部分则为目前的eventio格式中并不支持原生的xrootd读取和写入，目前我们使用xrdcf来进行包装来暂时解决这个问题。\nsim_telarray改装思路 在sim_telarray中情况也是类似，在Makefile中我们进行了优化，使其和hessioxxx类似能够一键配置。除此之外，为了与LACT相互搭配，下面的变化也被引入其中：\n默认的配置路径添加了cfg/lact 默认的配置文件改为了cfg/lact/lact.cfg 新增了lact_defaults.h文件，用于存放LACT的默认配置 在sim_telarray中，我们添加了选项--rmt，当读取EOS文件的时候，可以使用该选项。\n除此之外，为了更好细致的使用sim_telarray，我们对配置文件进行了相应的升级。目前的配置极大程度上依赖于HESS的电子学以及相应的光学参数。但这也是我们走向完整模拟的必经之路。 关于sim_telarray的详细配置，可以参考sim_telarray配置-LACT_PROD0\n","permalink":"https://zhipzhang.github.io/zh/simtelarrayadaption1/","summary":"\u003cp\u003e考虑到在LACT模拟中需要大量依赖于\u003ccode\u003ehessioxxx\u003c/code\u003e以及\u003ccode\u003esim_telarray\u003c/code\u003e工具包，而这两个工具包编译的过程比较繁琐，所以这里打算将这两个工具包进行改装，使其能够适应LACT的模拟需求。\u003c/p\u003e\n\u003ch2 id=\"hessioxxx改装思路\"\u003ehessioxxx改装思路\u003c/h2\u003e\n\u003cp\u003e在\u003ccode\u003ehessioxxx\u003c/code\u003e中，其存在大量为\u003ccode\u003eCTA\u003c/code\u003e以及\u003ccode\u003eHESS\u003c/code\u003e等项目定制的参数配置，因此在\u003ccode\u003eLACT\u003c/code\u003e进行使用的过程中及其不方便。考虑到最小化我们的修改情况，我们使用\u003ccode\u003eLACT_PROD\u003c/code\u003e参数来进行一键的配置。配置后我们可以使用下面的代码直接进行安装：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emake EXTRA_OPTIONS\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u0026#39;\u003c/span\u003e-DLACT_PROD0\u003cspan style=\"color:#e6db74\"\u003e`\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e以下是LACT_PROD0参数配置的说明表格：\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: left\"\u003e参数\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e值\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e说明\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eH_MAX_TEL\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e32\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e最大望远镜数量\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eH_MAX_PIX\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e3000\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e每个望远镜的最大像素数\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eH_MAX_GAINS\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e2\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e每个像素的最大增益通道数\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eH_MAX_PIXSECTORS\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e19\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e每个像素最多可以在多少个扇区之中\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eH_MAX_SECTORS\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003eH_MAX_PIX * 2\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e最大扇区数，为最大像素数的两倍\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eH_MAX_SLICES\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e128\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e最大采样的时间(ns)\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e修改的第二个部分则为目前的\u003ccode\u003eeventio\u003c/code\u003e格式中并不支持原生的\u003ccode\u003exrootd\u003c/code\u003e读取和写入，目前我们使用\u003ccode\u003exrdcf\u003c/code\u003e来进行包装来暂时解决这个问题。\u003c/p\u003e\n\u003ch2 id=\"sim_telarray改装思路\"\u003esim_telarray改装思路\u003c/h2\u003e\n\u003cp\u003e在\u003ccode\u003esim_telarray\u003c/code\u003e中情况也是类似，在\u003ccode\u003eMakefile\u003c/code\u003e中我们进行了优化，使其和\u003ccode\u003ehessioxxx\u003c/code\u003e类似能够一键配置。除此之外，为了与\u003ccode\u003eLACT\u003c/code\u003e相互搭配，下面的变化也被引入其中：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e默认的配置路径添加了cfg/lact\u003c/li\u003e\n\u003cli\u003e默认的配置文件改为了cfg/lact/lact.cfg\u003c/li\u003e\n\u003cli\u003e新增了lact_defaults.h文件，用于存放LACT的默认配置\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在\u003ccode\u003esim_telarray\u003c/code\u003e中，我们添加了选项\u003ccode\u003e--rmt\u003c/code\u003e，当读取\u003ccode\u003eEOS\u003c/code\u003e文件的时候，可以使用该选项。\u003c/p\u003e\n\u003cp\u003e除此之外，为了更好细致的使用\u003ccode\u003esim_telarray\u003c/code\u003e，我们对配置文件进行了相应的升级。目前的配置极大程度上依赖于\u003ccode\u003eHESS\u003c/code\u003e的电子学以及相应的光学参数。但这也是我们走向完整模拟的必经之路。\n关于sim_telarray的详细配置，可以参考\u003ca href=\"/zh/SimTelarrayConfiguration\"\u003esim_telarray配置-LACT_PROD0\u003c/a\u003e\u003c/p\u003e","title":"Sim_telarray 工具包改装计划"},{"content":"典型的 Corsika 输入卡介绍 以下是一个典型的 Corsika 输入卡的参数说明：\n参数 值 说明 RUNNR 1 运行编号 EVTNR 1 事件起始编号 NSHOW 1000 模拟事件数量 PRMPAR 1 初始粒子类型（1 表示伽马光子） ESLOPE -1.0 能谱指数 ERANGE 1 100 能量范围（单位：GeV） THETAP 0.0 0.0 天顶角范围（单位：度） PHIP 0. 0. 方位角范围（单位：度） VIEWCONE 0. 0. 视场角范围（单位：度） OBSLEV 3800.E2 观测高度（单位：厘米） ATMOSPHERE 1 F 大气模型（1 表示热带模型，F 表示不考虑大气折射） MAGNET 0.001 0.001 地磁场（单位：高斯） ARRANG 0. 望远镜阵列的旋转角度 CERSIZ 1. 切伦科夫光子束中光子的数量 CERFIL 0 是否输出切伦科夫光子文件（0 表示不输出） CWAVLG 260. 1000. 切伦科夫光波长范围（单位：纳米） TELESCOPE X. Y. Z. R. (多行) 望远镜位置（单位：厘米） CSCAT 10 800e2 0. 簇射重用参数 FIXHEI 0. 0 是否固定第一次相互作用高度 FIXCHI 0. 是否固定第一次相互作用深度 ELMFLG T T 是否开启电磁成分和多重散射 RADNKG 200.E2 NKG 公式半径（单位：厘米） HADFLG 0 0 0 0 0 2 强子相互作用标志 ECUTS 0.3 0.05 0.005 0.005 能量阈值（单位：GeV） MUADDI T 是否计算缪子附加信息 MUMULT T 是否开启缪子多重散射 LONGI T 20. F F 纵向发展输出设置 MAXPRT 0 是否输出单个粒子信息（0 表示不输出） ECTMAP 1.E2 电子-光子能量映射阈值（单位：GeV） TSTART T 是否输出起始时间 DATBAS yes 是否使用数据库 DEBUG F 6 F 1000000 调试设置 TELFIL iact.zst 输出文件名 DIRECT ./ 输出目录 PAROUT F F 是否输出粒子数据 IACT 多行 IACT 特定设置 SEED 多行 随机数种子 更详细的参数说明可以参考 Corsika 官方文档 和 sim_telarray 手册。\n特殊选项的讨论 CERSIZ CERSIZ 代表每个光子束中的光子数。通常情况下设置为 5，但如果你启用了大气吸收或量子效率模拟，建议将其设置为 1，以确保模拟的准确性。\nCSCAT CSCAT表示簇射被重用的次数，为了增加模拟数据的统计量，对于同一个簇射我们会多次使用，通常对于伽马射线，我们设置CSCAT = 10，对于宇宙线的事例，我们设置CSCAT = 20。后两个参数可以用来表示投点的范围，分别表示X方向和Y方向的投点范围。当Y方向的投点范围设置为0时，表示以圆进行投点。\nFIXHEI/FIXCHI FIXHEI 和 FIXCHI 用来控制是否固定第一次相互作用的高度和深度。默认情况下，两者都设为 0，表示不固定。如果你在研究特定高度的相互作用（如 Muon Ring），可以根据需要设置固定高度或深度。\nIACT 选项 如果使用 iactext 选项，可以通过 IACT 设置以下参数：\nIACT STORE_PARTICLES true：是否保存到达地面的粒子信息。 IACT STORE_EMITTERS true：是否保存发射切伦科夫光的粒子信息。 TELFIL：eventio格式的输出文件名，由于其特殊性，该选项可以开启各种扩展，从而实现pipe运行等。 corsika_run的使用 在lact账户下我们提供了corsika_run来直接执行corsik的模拟，其主要的配置参数如下:\nusage: corsika_run [-h] --corsika-path CORSIKA_PATH [--template TEMPLATE] --run-number RUN_NUMBER [--config-path CONFIG_PATH] [--keep-seeds] [--energy-range ENERGY_RANGE] [--particle-type PARTICLE_TYPE] [--atmosphere ATMOSPHERE] [--altitude ALTITUDE] Run CORSIKA simulation options: -h, --help show this help message and exit --corsika-path CORSIKA_PATH Path to CORSIKA executable --template TEMPLATE Path to template input file --run-number RUN_NUMBER Run number --config-path CONFIG_PATH Path to configuration directory --keep-seeds Keep seeds from template --energy-range ENERGY_RANGE Energy range for simulation --particle-type PARTICLE_TYPE Particle type for simulation --atmosphere ATMOSPHERE Atmosphere model number --altitude ALTITUDE Observation level altitude in meters 同场在使用中我们最好提供相应的template的基础文件，然后通过命令行参数进行调整。\n","permalink":"https://zhipzhang.github.io/zh/corsikainputcard/","summary":"\u003ch2 id=\"典型的-corsika-输入卡介绍\"\u003e典型的 Corsika 输入卡介绍\u003c/h2\u003e\n\u003cp\u003e以下是一个典型的 Corsika 输入卡的参数说明：\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: left\"\u003e参数\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e值\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e说明\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eRUNNR\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e1\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e运行编号\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eEVTNR\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e1\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e事件起始编号\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eNSHOW\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e1000\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e模拟事件数量\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003ePRMPAR\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e1\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e初始粒子类型（1 表示伽马光子）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eESLOPE\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e-1.0\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e能谱指数\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eERANGE\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e1 100\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e能量范围（单位：GeV）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eTHETAP\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e0.0 0.0\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e天顶角范围（单位：度）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003ePHIP\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e0. 0.\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e方位角范围（单位：度）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eVIEWCONE\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e0. 0.\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e视场角范围（单位：度）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eOBSLEV\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e3800.E2\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e观测高度（单位：厘米）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eATMOSPHERE\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e1 F\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e大气模型（1 表示热带模型，F 表示不考虑大气折射）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eMAGNET\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e0.001 0.001\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e地磁场（单位：高斯）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eARRANG\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e0.\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e望远镜阵列的旋转角度\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eCERSIZ\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e1.\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e切伦科夫光子束中光子的数量\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eCERFIL\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e0\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e是否输出切伦科夫光子文件（0 表示不输出）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eCWAVLG\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e260. 1000.\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e切伦科夫光波长范围（单位：纳米）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eTELESCOPE\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003eX. Y. Z. R. (多行)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e望远镜位置（单位：厘米）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eCSCAT\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e10 800e2 0.\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e簇射重用参数\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eFIXHEI\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e0. 0\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e是否固定第一次相互作用高度\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eFIXCHI\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e0.\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e是否固定第一次相互作用深度\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eELMFLG\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003eT T\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e是否开启电磁成分和多重散射\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eRADNKG\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e200.E2\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003eNKG 公式半径（单位：厘米）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eHADFLG\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e0 0 0 0 0 2\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e强子相互作用标志\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eECUTS\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e0.3 0.05 0.005 0.005\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e能量阈值（单位：GeV）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eMUADDI\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003eT\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e是否计算缪子附加信息\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eMUMULT\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003eT\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e是否开启缪子多重散射\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eLONGI\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003eT 20. F F\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e纵向发展输出设置\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eMAXPRT\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e0\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e是否输出单个粒子信息（0 表示不输出）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eECTMAP\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e1.E2\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e电子-光子能量映射阈值（单位：GeV）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eTSTART\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003eT\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e是否输出起始时间\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eDATBAS\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003eyes\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e是否使用数据库\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eDEBUG\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003eF 6 F 1000000\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e调试设置\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eTELFIL\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003eiact.zst\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e输出文件名\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eDIRECT\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e./\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e输出目录\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003ePAROUT\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003eF F\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e是否输出粒子数据\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eIACT\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e多行\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003eIACT 特定设置\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003eSEED\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e多行\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e随机数种子\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e更详细的参数说明可以参考 \u003ca href=\"https://www.ikp.kit.edu/corsika/corsika_manual.pdf\"\u003eCorsika 官方文档\u003c/a\u003e 和 \u003ccode\u003esim_telarray\u003c/code\u003e 手册。\u003c/p\u003e","title":"Corsika输入卡介绍"},{"content":"TODO: 补充Corisika的输入卡选项介绍， 补全读取粒子文件/切伦科夫光子文件的程序。\nCorsika 是一个对大气簇射进行模拟的程序，其可以模拟各种高能粒子在大气中发展的过程。具体信息可以参考Corsika官网并下载相应的用户手册。\nCorsika 安装 在这里我们利用Konrad提供的代码对Corsika进行安装，使用Konrad的脚本安装时我们不需要手动使用./coconut，只需直接运行脚本即可。在安装之前，我们首先需要预下载两个文件：gen_config和corsika_build_script。\n安装的步骤 下载gen_config和corsika_build_script， 将gen_config文件放置于bernlohr目录下，将corsika_build_script文件放置于corsika目录下。使用chmod +x对两个文件赋予执行权限。\nchmod +x gen_config chmod +x corsika_build_script 接着我们就可以直接使用./corsika_build_script运行安装Corsika了。在安装中我们可以指定多个选项：\nqgsII/epos/nexus: 选择对应的高能模型 urqmd/fluka: 选择对应的低能模型 iact: 选择是否安装IACT模块 iactext: 是否选择让输出的文件包括扩展块：比如原初粒子信息等 cerwlen: 是否考虑不同光子的波长，如果选择的话，短波长下对应的bunch size会变大。 viewcone: 在扩展源下需要使用该选项 volumecorr/volumedet: 选择探测器的类型： KM2A类粒子探测器/IACT atmext: 是否使用表状的大气模型 一些选项的讨论 在选择cerwlen选项之后，所有的光子都会按照$\\lambda^{-2}$的权重进行抽样，在短波处所对应的光子的数目会更多。除此之外，在该选项下会考虑不同波长所对应的折射率的不同，因此不同的光子所对应的发射角度也会不同。在接近阈值的情况下，该选项对结果的影响会更大。考虑到在该选项下，相同bunch size会对应着同样的波长，因此需要选择更小的bunch size。 默认一般情况下对应的配置选项为：iact atmext viewcone qgsII urqmd 因此使用下面代码进行安装： ./corsika_build_script iact atmext viewcone qgsII urqmd Corsika 使用 安装完成之后，我们需要就可以使用coriksa进行相应的模拟了。在corsika的run目录下会包含对应的可执行文件，例如:corsika77410Linux_QGSII_urqmd。将输入卡作为该程序的标准输入，就可以进行模拟了。在pylast中，我们使用corsika_run程序可以直接建立相应的工作目录开始相应的的模拟。\ncorsika_run --run-number 1 --corsika-path ~/Software/corsika-77410/run/corsika77410Linux_QGSII_urqmd --atmosphere ${atmosphere} --altitude ${altitude} --template ${current_dir}/template.input 在上述代码中，我们使用--run-number指定当前运行的run number，使用--corsika-path指定corsika程序的路径，使用--atmosphere指定大气模型，使用--altitude指定海拔高度，使用--template指定模版输入卡的路径。上述命令会在当前目录下建立一个工作目录：run000001，并自动运行corsika程序,corsika.input为对应的输入卡，corsika.output为对应的输出日志。输入卡的配置可以参照输入卡配置。\n","permalink":"https://zhipzhang.github.io/zh/corsikainstall/","summary":"\u003cp\u003eTODO: 补充Corisika的输入卡选项介绍， 补全读取粒子文件/切伦科夫光子文件的程序。\u003c/p\u003e\n\u003cp\u003eCorsika 是一个对大气簇射进行模拟的程序，其可以模拟各种高能粒子在大气中发展的过程。具体信息可以参考\u003ca href=\"https://www.iap.kit.edu/corsika\"\u003eCorsika官网\u003c/a\u003e并下载相应的用户手册。\u003c/p\u003e\n\u003ch1 id=\"corsika-安装\"\u003eCorsika 安装\u003c/h1\u003e\n\u003cp\u003e在这里我们利用Konrad提供的代码对Corsika进行安装，使用Konrad的脚本安装时我们不需要手动使用./coconut，只需直接运行脚本即可。在安装之前，我们首先需要预下载两个文件：\u003ca href=\"/downloads/gen_config\"\u003egen_config\u003c/a\u003e和\u003ca href=\"/downloads/corsika_build_script\"\u003ecorsika_build_script\u003c/a\u003e。\u003c/p\u003e\n\u003ch2 id=\"安装的步骤\"\u003e安装的步骤\u003c/h2\u003e\n\u003cp\u003e下载\u003ca href=\"/downloads/gen_config\"\u003egen_config\u003c/a\u003e和\u003ca href=\"/downloads/corsika_build_script\"\u003ecorsika_build_script\u003c/a\u003e， 将gen_config文件放置于bernlohr目录下，将corsika_build_script文件放置于corsika目录下。使用\u003ccode\u003echmod +x\u003c/code\u003e对两个文件赋予执行权限。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003echmod +x gen_config\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003echmod +x corsika_build_script\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e接着我们就可以直接使用\u003ccode\u003e./corsika_build_script\u003c/code\u003e运行安装Corsika了。在安装中我们可以指定多个选项：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eqgsII/epos/nexus: 选择对应的高能模型\u003c/li\u003e\n\u003cli\u003eurqmd/fluka: 选择对应的低能模型\u003c/li\u003e\n\u003cli\u003eiact: 选择是否安装IACT模块\u003c/li\u003e\n\u003cli\u003eiactext: 是否选择让输出的文件包括扩展块：比如原初粒子信息等\u003c/li\u003e\n\u003cli\u003ecerwlen: 是否考虑不同光子的波长，如果选择的话，短波长下对应的bunch size会变大。\u003c/li\u003e\n\u003cli\u003eviewcone: 在扩展源下需要使用该选项\u003c/li\u003e\n\u003cli\u003evolumecorr/volumedet: 选择探测器的类型： KM2A类粒子探测器/IACT\u003c/li\u003e\n\u003cli\u003eatmext: 是否使用表状的大气模型\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"一些选项的讨论\"\u003e一些选项的讨论\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e在选择\u003ccode\u003ecerwlen\u003c/code\u003e选项之后，所有的光子都会按照$\\lambda^{-2}$的权重进行抽样，在短波处所对应的光子的数目会更多。除此之外，在该选项下会考虑不同波长所对应的折射率的不同，因此不同的光子所对应的发射角度也会不同。在接近阈值的情况下，该选项对结果的影响会更大。考虑到在该选项下，相同bunch size会对应着同样的波长，因此需要选择更小的bunch size。\u003c/li\u003e\n\u003cli\u003e默认一般情况下对应的配置选项为：\u003ccode\u003eiact atmext viewcone qgsII urqmd\u003c/code\u003e\n因此使用下面代码进行安装：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e./corsika_build_script iact atmext viewcone qgsII urqmd\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"corsika-使用\"\u003eCorsika 使用\u003c/h1\u003e\n\u003cp\u003e安装完成之后，我们需要就可以使用coriksa进行相应的模拟了。在corsika的run目录下会包含对应的可执行文件，例如:\u003ccode\u003ecorsika77410Linux_QGSII_urqmd\u003c/code\u003e。将输入卡作为该程序的标准输入，就可以进行模拟了。在pylast中，我们使用\u003ccode\u003ecorsika_run\u003c/code\u003e程序可以直接建立相应的工作目录开始相应的的模拟。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecorsika_run --run-number \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e --corsika-path ~/Software/corsika-77410/run/corsika77410Linux_QGSII_urqmd --atmosphere \u003cspan style=\"color:#e6db74\"\u003e${\u003c/span\u003eatmosphere\u003cspan style=\"color:#e6db74\"\u003e}\u003c/span\u003e --altitude \u003cspan style=\"color:#e6db74\"\u003e${\u003c/span\u003ealtitude\u003cspan style=\"color:#e6db74\"\u003e}\u003c/span\u003e --template \u003cspan style=\"color:#e6db74\"\u003e${\u003c/span\u003ecurrent_dir\u003cspan style=\"color:#e6db74\"\u003e}\u003c/span\u003e/template.input\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在上述代码中，我们使用\u003ccode\u003e--run-number\u003c/code\u003e指定当前运行的run number，使用\u003ccode\u003e--corsika-path\u003c/code\u003e指定corsika程序的路径，使用\u003ccode\u003e--atmosphere\u003c/code\u003e指定大气模型，使用\u003ccode\u003e--altitude\u003c/code\u003e指定海拔高度，使用\u003ccode\u003e--template\u003c/code\u003e指定模版输入卡的路径。上述命令会在当前目录下建立一个工作目录：\u003ccode\u003erun000001\u003c/code\u003e，并自动运行corsika程序,\u003ccode\u003ecorsika.input\u003c/code\u003e为对应的输入卡，\u003ccode\u003ecorsika.output\u003c/code\u003e为对应的输出日志。输入卡的配置可以参照\u003ca href=\"/zh/CorsikaInputCard\"\u003e输入卡配置\u003c/a\u003e。\u003c/p\u003e","title":"Corsika Introduction"}]